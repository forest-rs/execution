---
id: et-9e42
status: in_progress
deps: [et-8a8d, et-2ef3, et-0123, et-3510]
links: [et-05c3, et-f999]
created: 2026-01-31T01:32:59Z
type: task
priority: 1
assignee: Bruce Mitchener
parent: et-8de9
tags: [execution_tape, vm]
---
# Implement interpreter + limits

Register VM with frames/recursion, fuel + max host calls + max depth, trap reporting with `SpanId` context.


## Notes

**2026-01-31T03:07:38Z**

Added initial VM interpreter (`execution_tape/src/vm.rs`): frames + regs, fuel/call-depth/host-call limits, span-aware `TrapInfo`, and execution for minimal opcode subset (`const_*`, `mov`, `br`/`jmp`, `call`/`ret`, `host_call`, `trap`). Added basic tests (const+ret, host call). fmt/clippy/test pass.

**2026-01-31T03:11:09Z**

Added `vm_branches` unit test covering `br` with byte-offset PCs (and fixed targets to instruction boundaries).

**2026-01-31T03:20:41Z**

Added more VM tests: `br`/`jmp` branching, fuel enforcement on infinite loop, host call limit enforcement, and `TrapInfo` `span_id` reporting from span table.

**2026-01-31T04:48:12Z**

**Overview**
- Goal: a small, predictable register VM that runs verified programs with hard execution limits and good error reporting.
- Non-goals (v1): async host calls, preemption/cancellation, JIT, rollback of side effects.

**Concepts + glossary**
- Frame: per-call execution state (`pc` + decoded instrs + reg window).
- Fuel: instruction budget (plus optional extra charges from host calls).
- Limits: hard caps (`fuel`, `max_call_depth`, `max_host_calls`) to bound runtime cost.
- `TrapInfo`: structured failure with `(func, pc, span_id)` for debugging/tracing.

**Why this shape**
- Frames + register arena keep execution simple and `no_std + alloc` friendly.
- Fuel/limits are required for embedding in interactive or untrusted environments (prevent infinite loops, runaway recursion, host-call storms).
- Span-aware traps are the foundation for future tracing/profiling and graph-level debugging.

**Usage example (embedder intent)**
- Embedder constructs a `Vm<Host>` with limits, runs `vm.run(&program, entry, args)`, gets either values or a `TrapInfo` with best-effort source/span context.

**Extension points**
- Add tracing hooks around instruction dispatch + host calls (see et-a842).
- Add aggregate and numeric op execution as the opcode set grows.

**Gotchas / risks**
- Host extra-fuel charging must be deterministic enough for your use-cases; keep it explicit and bounded.
- Re-entrancy policy needs to be nailed down once host calls can call back into the VM.

**2026-01-31T05:07:12Z**

VM now executes i64_add and tuple/struct/array aggregate ops with runtime traps for type/arity/OOB; added VM tests.
