---
id: et-7637
status: closed
deps: []
links: []
created: 2026-01-31T07:26:29Z
type: task
priority: 2
assignee: Bruce Mitchener
---
# String/bytes storage: validate UTF-8 once + avoid repeated checks

Today `Program` stores symbol/const blob bytes and returns `&str` via `from_utf8` at access time (e.g. `Program::symbol_str` / `Program::const_str`). This is correct but may re-run UTF-8 validation repeatedly across calls and keeps string/bytes handling intertwined. Track a design to validate UTF-8 once (during decode/build) and/or restructure storage to reduce overhead.

## Design

Ideas to explore:
- Decode-time validation: validate symbol/str blobs once in `Program::decode` and store validated ranges, or store an intern table of `&str`.
- Split storage: separate arenas for raw bytes and UTF-8 strings so string lookups don't touch byte-only payloads.
- API surface: consider adding fast-path accessors for verified programs that guarantee valid UTF-8.
- Format impact: try to avoid on-disk changes in v1 unless clearly necessary.
- Safety: do not introduce `unsafe`; keep `no_std + alloc`; keep `DecodeError::InvalidUtf8` on invalid inputs.

## Acceptance Criteria

- Chosen approach documented (pros/cons, what stays v1 vs v2).
- Implementation either caches UTF-8 validation or splits storage without format bump.
- Bench or microbench plan (even if not implemented yet) for symbol/const_str hot paths.


## Notes

**2026-01-31T07:26:36Z**

Related: we already split large const payloads into an arena (`et-8ab0`). This ticket is about reducing UTF-8 validation work and potentially separating `Str` vs `Bytes` representation/lookup, not about changing `const_pool` tagging semantics yet.
