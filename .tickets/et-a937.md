---
id: et-a937
status: open
deps: []
links: []
created: 2026-01-31T06:21:27Z
type: chore
priority: 3
assignee: Bruce Mitchener
parent: et-8de9
tags: [execution_tape, understory_dirty, design, notes]
---
# Ecosystem note: execution_tape + understory_dirty boundary (brainstorm)

Capture brainstorming context about how execution_tape might integrate with understory_dirty (dirty-tracking / incremental recompute), without committing to an API yet.

## Design

Notes (non-decisive):
- understory_dirty is for dirty-tracking / incremental recompute, not runtime or std-only glue.
- Likely multiple frontends will target execution_tape (graph compiler, scripting, etc.).
- A potential layering is: frontends -> shared IR/compiler -> execution_tape (portable execution); understory_dirty sits above execution to decide what to run and when.

Open questions to revisit later:
- Stable IDs: do we use SpanId, NodeId, FuncId, or a new stable key for dirty tracking?
- Value vs identity semantics for host objects and aggregates in cache keys.
- Handling side effects: do effectful ops opt out of caching, or do we track effect dependencies explicitly?
- Shape of the boundary: does understory_dirty schedule at function granularity, basic block, or node granularity?
- What metadata (names, spans, source mapping) is required to make incremental tracing/debugging usable?

No implementation planned; this is a memory aid ticket.

